<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Computer Networks - Unit 1 4-Mark Answers</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      background-color: #f4f7f6;
      margin: 0;
      padding: 0;
      color: #333;
    }
    .container {
      max-width: 900px;
      margin: 30px auto;
      padding: 20px;
      background-color: #fff;
      box-shadow: 0 0 15px rgba(0, 0, 0, 0.1);
      border-radius: 8px;
    }
    h1 {
      text-align: center;
      color: #2d3e50;
    }
    h2 {
      color: #2c3e50;
      border-bottom: 2px solid #3498db;
      padding-bottom: 5px;
      margin-top: 30px;
    }
    h3 {
      margin-top: 15px;
      color: #34495e;
    }
    p {
      line-height: 1.6;
    }
    ul {
      line-height: 1.6;
      padding-left: 20px;
    }
    .answer {
      background-color: #eef2f3;
      padding: 15px;
      border-left: 5px solid #3498db;
      border-radius: 5px;
      margin-bottom: 20px;
    }
    table {
      width: 100%;
      border-collapse: collapse;
      margin: 15px 0;
    }
    table, th, td {
      border: 1px solid #ddd;
    }
    th, td {
      padding: 10px;
      text-align: left;
    }
    th {
      background-color: #3498db;
      color: white;
    }
    footer {
      text-align: center;
      font-size: 0.9em;
      color: #aaa;
      margin-top: 30px;
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>Computer Networks - Unit 1 4-Mark Answers</h1>

    <!-- Question 1 -->
    <section>
      <h2>1. Explain Store and Forward Packet Switching</h2>
      <div class="answer">
        <p>
          <strong>Store and Forward Packet Switching</strong> is a technique in which each node in a network stores the entire packet before forwarding it to the next node.
        </p>
        <ul>
          <li>The packet is received, checked for errors using checksum, and then transmitted.</li>
          <li>If errors are detected, the packet is discarded.</li>
          <li>Ensures error-free delivery but introduces a delay at each node.</li>
          <li>Common in WANs and reliable data transmission systems.</li>
        </ul>
        <h3>Advantages:</h3>
        <ul>
          <li>Error detection and correction before forwarding.</li>
          <li>Reduces the chance of corrupted packets in the network.</li>
        </ul>
        <h3>Disadvantages:</h3>
        <ul>
          <li>Delay increases with the number of intermediate nodes.</li>
        </ul>
      </div>
    </section>

    <!-- Question 2 -->
    <section>
      <h2>2. Distance Vector Routing and Link State Routing</h2>
      <div class="answer">
        <h3>Distance Vector Routing:</h3>
        <ul>
          <li>Each router maintains a table indicating the distance (cost) to each destination.</li>
          <li>Routers share this table periodically with neighbors.</li>
          <li>Bellman-Ford algorithm is used.</li>
          <li>Convergence is slow, and it suffers from the count-to-infinity problem.</li>
        </ul>
        <h3>Link State Routing:</h3>
        <ul>
          <li>Each router builds a map of the entire network topology.</li>
          <li>Routers exchange link state packets (LSP) to describe their connectivity.</li>
          <li>Dijkstra’s algorithm is used to compute the shortest path.</li>
          <li>Converges faster and is more reliable.</li>
        </ul>
        <h3>Comparison:</h3>
        <table>
          <tr>
            <th>Distance Vector Routing</th>
            <th>Link State Routing</th>
          </tr>
          <tr>
            <td>Slower convergence</td>
            <td>Faster convergence</td>
          </tr>
          <tr>
            <td>Suffers from count-to-infinity problem</td>
            <td>More reliable</td>
          </tr>
          <tr>
            <td>Uses Bellman-Ford algorithm</td>
            <td>Uses Dijkstra’s algorithm</td>
          </tr>
        </table>
      </div>
    </section>

    <!-- Question 3 -->
    <section>
      <h2>3. Broadcast Routing</h2>
      <div class="answer">
        <p>
          <strong>Broadcast Routing</strong> sends a packet to all nodes in a network.
        </p>
        <h3>Techniques:</h3>
        <ul>
          <li><strong>Flooding:</strong> Every node forwards packets to all neighbors, causing duplication.</li>
          <li><strong>Reverse Path Forwarding (RPF):</strong> Packet is forwarded only if it arrives on the shortest path to the source.</li>
          <li><strong>Multidestination Routing:</strong> Packet carries a list of destinations; routers split and forward to specific destinations.</li>
          <li><strong>Broadcasting in LANs:</strong> Performed using MAC-level broadcast (e.g., ARP).</li>
        </ul>
        <h3>Applications:</h3>
        <ul>
          <li>ARP requests.</li>
          <li>Routing table updates in distance vector routing.</li>
        </ul>
      </div>
    </section>

    <!-- Question 4 -->
    <section>
      <h2>4. Hierarchical Routing with Example</h2>
      <div class="answer">
        <p>
          <strong>Hierarchical Routing</strong> is used in large networks by dividing them into regions to reduce routing complexity.
        </p>
        <h3>Concept:</h3>
        <ul>
          <li>Routers maintain detailed routing information for their region and summary information about other regions.</li>
          <li>Reduces the size of routing tables.</li>
        </ul>
        <h3>Example:</h3>
        <p>
          Consider a network divided into 3 regions (A, B, C). A router within region A knows the paths within A but only the gateway routers for regions B and C.
        </p>
        <h3>Advantages:</h3>
        <ul>
          <li>Scalable and efficient for large networks.</li>
          <li>Reduces overhead and processing time.</li>
        </ul>
      </div>
    </section>

    <!-- Question 5 -->
    <section>
      <h2>5. Routing in Ad Hoc Networks</h2>
      <div class="answer">
        <p>
          <strong>Ad hoc networks</strong> are self-configuring networks where devices communicate without infrastructure.
        </p>
        <h3>Types of Routing Protocols:</h3>
        <ul>
          <li><strong>Proactive (Table-driven):</strong> Nodes maintain up-to-date routing tables (e.g., DSDV).</li>
          <li><strong>Reactive (On-demand):</strong> Routes are created when needed (e.g., AODV, DSR).</li>
          <li><strong>Hybrid:</strong> Combination of both (e.g., ZRP).</li>
        </ul>
        <h3>Challenges:</h3>
        <ul>
          <li>Frequent topology changes.</li>
          <li>Limited power and bandwidth.</li>
        </ul>
        <h3>Applications:</h3>
        <ul>
          <li>Military, disaster recovery, IoT.</li>
        </ul>
      </div>
    </section>

    <!-- Question 6 -->
    <section>
      <h2>6. Short Notes</h2>
      <div class="answer">
        <ul>
          <li>
            <strong>Multicast:</strong> Delivery of data to a group of destinations simultaneously using multicast groups (e.g., IPTV, video conferencing).
          </li>
          <li>
            <strong>Anycast:</strong> Data is sent to the nearest node from a group. Used in DNS and CDN for load balancing.
          </li>
          <li>
            <strong>Admission Control:</strong> Determines if new traffic can be admitted based on available resources to ensure QoS.
          </li>
          <li>
            <strong>Load Shedding:</strong> Discarding lower-priority packets when the network is congested to maintain performance for critical traffic.
          </li>
          <li>
            <strong>Flooding:</strong> Each packet is sent to all neighbors, ensuring delivery but causing redundancy and network congestion.
          </li>
        </ul>
      </div>
    </section>

    <!-- Question 7 -->
    <section>
      <h2>7. Approaches to Congestion Control</h2>
      <div class="answer">
        <p>
          <strong>Congestion control</strong> prevents network overload.
        </p>
        <h3>Approaches:</h3>
        <ul>
          <li><strong>Open-loop:</strong> Prevent congestion (e.g., traffic shaping, admission control).</li>
          <li><strong>Closed-loop:</strong> Detect and react to congestion (e.g., TCP congestion control).</li>
          <li><strong>Congestion Avoidance:</strong> Early detection (e.g., RED algorithm).</li>
        </ul>
        <h3>Examples:</h3>
        <ul>
          <li>TCP uses window size adjustment based on network congestion.</li>
          <li>Packet dropping when queues are full.</li>
        </ul>
      </div>
    </section>

    <!-- Question 8 -->
    <section>
      <h2>8. Integrated Services vs Differentiated Services in QoS</h2>
      <div class="answer">
        <h3>Integrated Services (IntServ):</h3>
        <ul>
          <li>Per-flow resource reservation using RSVP protocol.</li>
          <li>Guaranteed bandwidth and delay.</li>
          <li>Suitable for real-time applications but not scalable.</li>
        </ul>
        <h3>Differentiated Services (DiffServ):</h3>
        <ul>
          <li>Class-based traffic handling (e.g., Expedited Forwarding, Assured Forwarding).</li>
          <li>Scalable but offers relative QoS.</li>
          <li>Used in large networks like ISPs.</li>
        </ul>
        <h3>Key Difference:</h3>
        <p>
          IntServ is resource-intensive but precise; DiffServ is scalable with priority-based QoS.
        </p>
      </div>
    </section>

    <!-- Question 9 -->
    <section>
      <h2>9. Bellman-Ford Algorithm (Distance Vector Routing)</h2>
      <div class="answer">
        <h3>Steps:</h3>
        <ul>
          <li>Initialize distances to all nodes as infinity, source as 0.</li>
          <li>Each router exchanges its table with neighbors.</li>
          <li>Update the table if a shorter path is found.</li>
          <li>Repeat until no changes occur.</li>
        </ul>
        <h3>Key Features:</h3>
        <ul>
          <li>Suitable for smaller networks.</li>
          <li>Prone to slow convergence and count-to-infinity.</li>
        </ul>
      </div>
    </section>

    <!-- Question 10 -->
    <section>
      <h2>10. Virtual Circuit vs Datagram Subnets</h2>
      <div class="answer">
        <p>
          <strong>Example:</strong>
        </p>
        <ul>
          <li><strong>Virtual Circuit:</strong> Resembles a telephone system.</li>
          <li><strong>Datagram:</strong> Similar to a postal service.</li>
        </ul>
      </div>
    </section>

    <!-- Question 11 -->
    <section>
      <h2>11. Traffic-Aware Routing</h2>
      <div class="answer">
        <p>
          <strong>Traffic-aware routing</strong> considers current network traffic to avoid congested paths.
        </p>
        <h3>Examples:</h3>
        <ul>
          <li><strong>OSPF with Traffic Engineering (OSPF-TE):</strong> Uses real-time traffic data.</li>
          <li><strong>Adaptive Routing:</strong> Changes paths dynamically based on congestion.</li>
        </ul>
        <h3>Benefits:</h3>
        <ul>
          <li>Reduces delays and packet loss.</li>
          <li>Improves network performance during high traffic.</li>
        </ul>
      </div>
    </section>

    <!-- Question 12 -->
    <section>
      <h2>12. Problems in Dijkstra’s Shortest Path</h2>
      <div class="answer">
        <h3>Algorithm Steps:</h3>
        <ul>
          <li>Assign initial distances (0 to source, infinity to others).</li>
          <li>Select the node with the smallest distance.</li>
          <li>Update distances to its neighbors.</li>
          <li>Mark the node as visited.</li>
          <li>Repeat until all nodes are visited.</li>
        </ul>
        <h3>Example:</h3>
        <p>
          Shortest Path from A to D: A → E → F → D (Cost: 1 + 4 + 2 = 7)
        </p>
        <h3>Applications:</h3>
        <ul>
          <li>OSPF protocol.</li>
          <li>Google Maps pathfinding.</li>
        </ul>
      </div>
    </section>

    <footer>
      <p>Computer Networks - Unit 1 | 2025</p>
    </footer>
  </div>
</body>
</html>
