<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>8086 Microprocessor Concepts</title>
  <!-- Google Fonts -->
  <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;600&display=swap" rel="stylesheet">
  <style>
    /* Global Styles */
    * {
      box-sizing: border-box;
    }
    body {
      margin: 0;
      padding: 0;
      font-family: 'Poppins', sans-serif;
      background: linear-gradient(135deg, #1e3c72, #2a5298);
      color: #333;
      overflow-x: hidden;
    }
    header {
      text-align: center;
      padding: 2rem 1rem;
      background: rgba(255, 255, 255, 0.1);
      backdrop-filter: blur(5px);
      margin-bottom: 2rem;
      animation: fadeInDown 1s ease-out;
    }
    header h1 {
      margin: 0;
      font-size: 2.8rem;
      color: #fff;
    }
    .container {
      max-width: 900px;
      margin: 0 auto 2rem;
      padding: 2rem;
      background: #fff;
      border-radius: 12px;
      box-shadow: 0 10px 20px rgba(0, 0, 0, 0.2);
      animation: fadeInUp 1s ease-out;
    }
    .section {
      margin-bottom: 2rem;
      opacity: 0;
      animation: fadeIn 1s forwards;
    }
    .section:nth-child(odd) {
      animation-delay: 0.3s;
    }
    .section:nth-child(even) {
      animation-delay: 0.6s;
    }
    .section h2 {
      font-size: 1.8rem;
      margin-bottom: 0.5rem;
      border-bottom: 2px solid #2a5298;
      padding-bottom: 0.3rem;
      color: #2a5298;
    }
    .section p {
      margin: 0.8rem 0;
      line-height: 1.5;
    }
    ul {
      margin-left: 1.5rem;
      list-style: disc;
    }
    .sub-list {
      margin-left: 1.5rem;
      list-style-type: circle;
    }
    pre {
      background: #f4f4f4;
      padding: 1rem;
      border-left: 5px solid #2a5298;
      border-radius: 5px;
      overflow-x: auto;
      font-size: 0.95rem;
    }
    code {
      background: #f4f4f4;
      padding: 0.2rem 0.4rem;
      border-radius: 3px;
      font-family: 'Courier New', monospace;
    }
    footer {
      text-align: center;
      color: #fff;
      padding: 1rem;
      font-size: 0.9rem;
    }
    /* Animations */
    @keyframes fadeInDown {
      from { opacity: 0; transform: translateY(-20px); }
      to { opacity: 1; transform: translateY(0); }
    }
    @keyframes fadeInUp {
      from { opacity: 0; transform: translateY(20px); }
      to { opacity: 1; transform: translateY(0); }
    }
    @keyframes fadeIn {
      from { opacity: 0; }
      to { opacity: 1; }
    }
    /* Responsive Design */
    @media (max-width: 600px) {
      .container {
        padding: 1.5rem;
      }
      header h1 {
        font-size: 2rem;
      }
      .section h2 {
        font-size: 1.5rem;
      }
    }
  </style>
</head>
<body>
  <header>
    <h1>8086 Microprocessor Concepts &amp; Assembly Instructions</h1>
  </header>
  
  <div class="container">
    <!-- Question 1 -->
    <div class="section" id="flags">
      <h2>1. Different Types of Flags with Example</h2>
      <p>
        Flags are special bits within the flag register that indicate the status of the processor after an operation. Some common flags include:
      </p>
      <ul>
        <li><strong>Zero Flag (ZF):</strong> Set when the result is zero.</li>
        <li><strong>Sign Flag (SF):</strong> Indicates the sign of the result (1 for negative, 0 for positive).</li>
        <li><strong>Carry Flag (CF):</strong> Indicates an overflow out of the most significant bit in an unsigned operation.</li>
        <li><strong>Overflow Flag (OF):</strong> Indicates that the result of a signed operation is too large to be represented.</li>
        <li><strong>Auxiliary Carry Flag (AF):</strong> Used in binary-coded decimal (BCD) arithmetic.</li>
        <li><strong>Parity Flag (PF):</strong> Set if the number of set bits in the result is even.</li>
      </ul>
      <p>
        <em>Example:</em> After adding two numbers, if the result is zero, the Zero Flag (ZF) will be set.
      </p>
    </div>
    
    <!-- Question 2 -->
    <div class="section" id="physical-address">
      <h2>2. Finding the Physical Address</h2>
      <p>
        In the 8086 microprocessor, the physical address is calculated using the segment:offset addressing scheme. The formula is:
      </p>
      <p>
        <strong>Physical Address = (Segment Ã— 16) + Offset</strong>
      </p>
      <p>
        <em>Example:</em> If the segment is <code>0x2000</code> and the offset is <code>0x0010</code>, then:
      </p>
      <pre>
Physical Address = (0x2000 * 16) + 0x0010
                 = 0x20000 + 0x0010
                 = 0x20010
      </pre>
    </div>
    
    <!-- Question 3 -->
    <div class="section" id="addressing-modes">
      <h2>3. Types of Addressing Modes</h2>
      <p>
        Addressing modes determine how the operand of an instruction is accessed. Common modes include:
      </p>
      <ul>
        <li><strong>Immediate Addressing:</strong> The operand is specified directly within the instruction.</li>
        <li><strong>Register Addressing:</strong> The operand is stored in a register.</li>
        <li><strong>Direct Addressing:</strong> The memory address of the operand is given explicitly.</li>
        <li><strong>Indirect Addressing:</strong> The instruction specifies a register or memory location that contains the address of the operand.</li>
        <li><strong>Based/Indexed Addressing:</strong> Combines a base register and an index register to form the effective address.</li>
      </ul>
      <p>
        <em>Example:</em> The instruction <code>MOV AX, [1234H]</code> uses direct addressing to access the operand at memory location <code>1234H</code>.
      </p>
    </div>
    
    <!-- Question 4 -->
    <div class="section" id="assembly-programs">
      <h2>4. Writing Assembly Language Programs</h2>
      <p>
        Assembly language programs consist of instructions executed by the processor. Below is a simple program that adds two numbers and stores the result:
      </p>
      <pre>
; Simple Assembly Program to Add Two Numbers

.MODEL SMALL
.STACK 100h

.DATA
    NUM1    DW 5
    NUM2    DW 10
    RESULT  DW ?

.CODE
MAIN PROC
    MOV AX, @DATA  ; Initialize data segment
    MOV DS, AX

    MOV AX, NUM1   ; Load first number into AX
    ADD AX, NUM2   ; Add second number to AX
    MOV RESULT, AX ; Store result

    MOV AH, 4Ch    ; Terminate program
    INT 21h
MAIN ENDP
.END MAIN
      </pre>
      <p>
        This program initializes the data segment, loads the numbers into the AX register, adds them, and then stores the result.
      </p>
    </div>
    
    <!-- Question 5 -->
    <div class="section" id="shift-rotate">
      <h2>5. Types of Shift and Rotate Instructions</h2>
      <p>
        The 8086 microprocessor provides instructions to shift and rotate bits within a register:
      </p>
      <ul>
        <li>
          <strong>Shift Instructions:</strong>
          <ul class="sub-list">
            <li><em>Logical Shift Left (SHL):</em> Shifts bits left and fills the rightmost bit with zero.</li>
            <li><em>Logical Shift Right (SHR):</em> Shifts bits right and fills the leftmost bit with zero.</li>
            <li><em>Arithmetic Shift Right (SAR):</em> Shifts bits right while preserving the sign bit.</li>
          </ul>
        </li>
        <li>
          <strong>Rotate Instructions:</strong>
          <ul class="sub-list">
            <li><em>Rotate Left (ROL):</em> Rotates bits left; the bit shifted out from the left is reintroduced on the right.</li>
            <li><em>Rotate Right (ROR):</em> Rotates bits right; the bit shifted out from the right is reintroduced on the left.</li>
          </ul>
        </li>
      </ul>
      <p>
        <em>Example:</em> The instruction <code>SHL AX, 1</code> shifts the contents of the AX register one bit to the left.
      </p>
    </div>
    
    <!-- Question 6 -->
    <div class="section" id="difference-shift-rotate">
      <h2>6. Difference Between Shift and Rotate Instructions</h2>
      <p>
        The key differences between shift and rotate instructions are:
      </p>
      <ul>
        <li><strong>Bit Loss:</strong> In shift operations, bits shifted out are lost. In rotate operations, bits circulate so no data is lost.</li>
        <li><strong>Zero Fill:</strong> Shift instructions fill the vacant positions with zeros, while rotate instructions reuse the shifted bits.</li>
        <li><strong>Sign Preservation:</strong> Arithmetic shifts (e.g., SAR) preserve the sign bit for signed numbers, a feature not applicable to rotate instructions.</li>
      </ul>
    </div>
    
    <!-- Question 7 -->
    <div class="section" id="assembler-directives">
      <h2>7. Types of Assembler Directives</h2>
      <p>
        Assembler directives guide the assembly process rather than generating machine code. Common directives include:
      </p>
      <ul>
        <li><strong>MODEL:</strong> Specifies the memory model (e.g., SMALL, MEDIUM).</li>
        <li><strong>STACK:</strong> Defines the size of the stack.</li>
        <li><strong>.DATA and .CODE:</strong> Define the data and code segments respectively.</li>
        <li><strong>ORG:</strong> Sets the starting address for a segment.</li>
        <li><strong>END:</strong> Indicates the end of the source code.</li>
        <li><strong>DB, DW, DD:</strong> Used to declare data (byte, word, or double word).</li>
      </ul>
      <p>
        <em>Example:</em> The directive <code>.DATA NUM DB 10</code> creates a byte of data with the value 10.
      </p>
    </div>
    
    <!-- Question 8 -->
    <div class="section" id="structure-8086">
      <h2>8. Structure of the 8086 Microprocessor</h2>
      <p>
        The 8086 microprocessor architecture is divided into two main units:
      </p>
      <ul>
        <li>
          <strong>Execution Unit (EU):</strong>
          <ul class="sub-list">
            <li>Performs arithmetic, logical, and control operations.</li>
            <li>Contains registers such as AX, BX, CX, DX, and flag registers.</li>
          </ul>
        </li>
        <li>
          <strong>Bus Interface Unit (BIU):</strong>
          <ul class="sub-list">
            <li>Manages data and instruction fetching, memory addressing, and system bus interfacing.</li>
            <li>Handles segment registers (CS, DS, SS, ES) and computes physical addresses.</li>
          </ul>
        </li>
      </ul>
      <p>
        The separation of the EU and BIU allows overlapping of instruction fetch and execution, thereby improving overall performance.
      </p>
    </div>
    
  </div>
  
  <footer>
    &copy; 2025 8086 Concepts. All rights reserved.
  </footer>
</body>
</html>
